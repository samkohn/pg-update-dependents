import argparse
import dataclasses
import getpass
import pprint
from typing import Literal

import networkx as nx

from . import sql


@dataclasses.dataclass(frozen=True)
class SQLObject:
    schema: str
    name: str
    kind: Literal["v"] | Literal["m"]
    oid: int

    def __str__(self) -> str:
        return self.schema + '.' + self.name

    def str_safe(self) -> str:
        return sql.safe_obj_name(self.schema, self.name)


@dataclasses.dataclass
class Action:
    action_type: Literal["drop"] | Literal["create"]
    obj: SQLObject
    definition: str | None = None

    def __str__(self) -> str:
        return self.action_type + " " + str(self.obj)

    def to_sql(self) -> str:
        if self.action_type == "drop":
            if self.obj.kind == "v":
                kind_str = "VIEW"
            elif self.obj.kind == "m":
                kind_str = "MATERIALIZED VIEW"
            return f"DROP {kind_str} {self.obj.str_safe()};"
        elif self.definition is None:
            raise ValueError(f"Unknown CREATE definition for {self}")
        elif self.action_type == "create":
            return self.definition


def raw_to_edge(raw_row: list) -> tuple[SQLObject, SQLObject]:
    dep_schema, dep_name, dep_oid, dep_kind, s_schema, s_name, s_oid, s_kind = raw_row
    return (
        SQLObject(s_schema, s_name, s_kind, s_oid),
        SQLObject(dep_schema, dep_name, dep_kind, dep_oid),
    )


def create_edge_list(raw_sql_results: list) -> list[tuple[SQLObject, SQLObject]]:
    return [raw_to_edge(row) for row in raw_sql_results]


def order(graph, targets: list[SQLObject]) -> dict[str, list[Action]]:
    # Find all (potentially overlapping) subgraphs containing each target
    # and their descendents
    subgraphs = [graph.subgraph(nx.descendants(graph, target) | {target}) for target in targets]
    # nx.compose computes the overlap of all the graphs.
    # For graphs (V1, E1) and (V2, E2), this computes (V1 union V2, E1 union E2)
    # which is different from the traditional notion of graph union
    # but similar to that of set union.
    combined = subgraphs[0]
    for subgraph in subgraphs:
        combined = nx.compose(combined, subgraph)
    nx.nx_agraph.write_dot(combined, 'out.dot')
    topo_order = list(nx.lexicographical_topological_sort(combined, key=lambda o:str(o)))
    drops = [Action("drop", node) for node in reversed(topo_order)]
    creates = [Action("create", node) for node in topo_order]
    return {
            "drops": drops,
            "creates": creates,
           }


def drop_then_create(steps: dict[str, list[Action]], targets: list[SQLObject]) -> str:
    target_comment = "\n    -- TARGET RELATION --\n\n"
    script = (
        f"""\n\n\n\n-- DROP DEPENDENT RELATIONS --\n\n\n"""
        + "\n\n".join((target_comment if step.obj in targets else "") + step.to_sql() for step in steps["drops"])
        + "\n\n\n\n    -- CREATE DEPENDENT RELATIONS --\n\n"
        + "\n\n".join((target_comment if step.obj in targets else "") + step.to_sql() for step in steps["creates"])
    )
    return script


def script_intro(targets: list[SQLObject]) -> str:
    targets_safe = "\n--    ".join([target.str_safe() for target in targets])
    target_comment = "\n    -- TARGET RELATION --\n\n"
    script = f"""-- This file was auto-generated by pg-update-dependents.
-- Targets:

--    {targets_safe}

-- First, all dependent relations are dropped.
-- The target relations are preceded by the comment

{target_comment}
-- After the final target relation, all the CREATE statements
-- for dependent relations are included.
-- The targets' definitions can be modified, and any dependent relations
-- can also be modified. As long as the schema is not modified between
-- the generation and execution of this file, it is guaranteed to
-- contain all dependent views and materialized views.

BEGIN TRANSACTION;"""
    return script


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-u", "--user", required=True)
    parser.add_argument("-t", "--host", required=True)
    parser.add_argument("-d", "--db", required=True)
    parser.add_argument("-p", "--port", type=int, required=True)
    parser.add_argument(
        "-w", "--password", help="Will prompt for password if not provided"
    )
    parser.add_argument("-o", "--outfile", required=True)
    parser.add_argument("targets", nargs="+")
    parser.add_argument(
        "--with-no-data",
        action="store_true",
        help="Postpone populating materialized views until the end of the script",
    )
    args = parser.parse_args()
    if not args.password:
        args.password = getpass.getpass()
    conn = sql.get_conn(args.user, args.host, args.db, args.port, args.password)
    raw = sql.get_sql_objects_raw(conn)
    edge_list = create_edge_list(raw)
    all_objects = set(e[0] for e in edge_list) | set(e[1] for e in edge_list)
    target_names = [target.split(".") for target in args.targets]
    target_objs = {}
    for target_schema, target_name in target_names:
        for obj in all_objects:
            if obj.schema == target_schema and obj.name == target_name:
                if (target_schema, target_name) not in target_objs:
                    target_objs[target_schema, target_name] = obj
                else:
                    raise ValueError(
                        "There must be exactly one db object matching the target "
                        f"{target_schema}.{target_name}, "
                        "but I found another (at least 2): "
                        f"{target_objs[target_schema, target_name]} and {obj}"
                    )
    graph = nx.DiGraph(edge_list)
    steps_by_type = order(graph, target_objs.values())
    steps = steps_by_type["drops"] + steps_by_type["creates"]
    reverse_steps = list(reversed(steps))
    definitions = sql.retrieve_definitions(
        conn,
        [action.obj for action in reverse_steps if action.action_type == "create"],
        args.with_no_data,
    )
    for step, definition in zip(reverse_steps, definitions):
        step.definition = "\n".join(definition).strip()

    script = script_intro(target_objs.values())
    script += drop_then_create(steps_by_type, target_objs.values())
    if args.with_no_data:
        # Manually refresh materialized views, in the correct order
        refreshes = [f"REFRESH MATERIALIZED VIEW {step.obj.str_safe()};" for step in
                     steps_by_type["creates"] if step.obj.kind == "m"]
        script += "\n\n-- Populate all materialized views\n\n" + "\n\n".join(refreshes)
    script += "\n\nCOMMIT;"

    with open(args.outfile, "w") as f:
        f.write(script)


if __name__ == "__main__":
    main()
